syntax = "proto3";

import "common.proto";
import "transaction.proto";
import "block.proto";
import "google/protobuf/timestamp.proto";


// WIP - will change


message BlockNumber {
    Hash   parent_hash = 1;
    uint64 height      = 2;
    uint64 fork_id     = 3;
}

enum Step {
    Propose = 0;
    Prevote = 1;
    Precommit = 2;
}

message Vote {
    enum  VoteType {
        Prevote   = 0;
        Precommit = 1;
    };

    // We use a type field to distinguish between prevotes and precommits instead of different
    // messages, to make sure the data, and therefore the signature, are unambiguous, since the
    // votes have the same fields.
    VoteType           vote_type    = 1;
    BlockNumber        block_number = 2;
    uint32             round        = 3;
    // This is optional since a vote can be NIL.
    optional Hash      block_hash   = 4;
    // Identifies the voter.
    Address            voter        = 5;
    // Voter's signature of the above fields.
    ConsensusSignature signature    = 6;
}

message ProposalInit {
    BlockNumber               block_number   = 1;
    uint32                    proposal_round = 2;
    optional uint32           valid_round    = 3;
    Address                   proposer       = 4;
    google.protobuf.Timestamp timestamp      = 5;
    // Proposer's signature on the above fields.
    ConsensusSignature        signature      = 6;
}

// Any content in the block itself, which is opaque to the consensus module (e.g. transactions,
// proofs, gas price, etc.)
message ProposalContent {
    oneof content {
        Transactions transactions = 1;
        BlockProof   proof        = 2;
    }

    BlockNumber block_number = 3;
    uint32      round        = 4;
    // Proposer's signature on the above fields.
    ConsensusSignature signature = 5;
}

message ProposalFin {
    Hash               block_hash       = 1;
    // Proposer's signature of (block_number, round, block_hash).
    ConsensusSignature block_signature  = 2;
}

message ProposalPart {
    oneof messages {
        ProposalInit    init    = 1;
        ProposalContent content = 2;
        ProposalFin     fin     = 3;
    }
}

// A proposal is a stream:
// 1. The first message is `init`.
// 2. The next N messages are `content`.
// 3. The last message is `fin`.
message ProposalMessage {
    repeated ProposalPart parts = 1;
}

message CertificateInit {
    ProposalInit       init             = 1;
    Hash               block_hash       = 2;
    // Proposer's signature of (block_number, round, block_hash).
    ConsensusSignature block_signature  = 3;
    // Votes of 1 type which form a quorum in favor of the proposal.
    repeated Vote      votes            = 4;
}

// A proposal is a stream:
// 1. The first message is `init`.
// 2. The next N messages are `content`.
message Certificate {
    oneof messages {
        CertificateInit init    = 1;
        ProposalContent content = 2;
    }
}

message PeerState {
    BlockNumber        block_number = 1;
    uint32             round        = 2;
    Step               step         = 3;
    uint32             valid_round  = 4;
    Hash               valid_value  = 5;
}
