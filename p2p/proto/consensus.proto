syntax = "proto3";

import "common.proto";
import "transaction.proto";
import "block.proto";
import "google/protobuf/timestamp.proto";


// WIP - will change


message BlockLocation {
    Hash   parent_hash = 1;
    uint64 height      = 2;
    uint64 fork_id     = 3;
}

enum Step {
    Propose = 0;
    Prevote = 1;
    Precommit = 2;
}

message Vote {
    enum  VoteType {
        Prevote   = 0;
        Precommit = 1;
    };

    // We use a type field to distinguish between prevotes and precommits instead of different
    // messages, to make sure the data, and therefore the signature, are unambiguous, since the
    // votes have the same fields.
    VoteType           vote_type      = 2;
    BlockLocation      block_location = 3;
    uint32             round          = 4;
    // This is optional since a vote can be NIL.
    optional Hash      block_hash     = 5;
    // Identifies the voter.
    Address            voter          = 6;
    // Voter's signature of the above fields.
    ConsensusSignature signature      = 7;
}

message ProposalInit {
    BlockLocation             block_location = 1;
    uint32                    proposal_round = 2;
    optional uint32           valid_round    = 3;
    Address                   proposer       = 4;
    google.protobuf.Timestamp timestamp      = 5;
    // Proposer's signature on the above fields.
    ConsensusSignature        signature      = 6;
}

// The primary content of the block. This is opaque to the consensus module (e.g. transactions,
// proofs, gas price, etc.)
message ProposalContent {
    oneof content {
        Transactions transactions = 1;
        BlockProof   proof        = 2;
    }

    // The sequence number of this content within the proposal.
    uint32 sequence_number        = 3;

    // Proposal builder's signature on the above fields.
    ConsensusSignature signature  = 4;
}

message ProposalFin {
    Hash               block_hash       = 1;
    // Proposer's signature of (block_location, round, block_hash).
    ConsensusSignature block_signature  = 2;
}

message ProposalPart {
    oneof messages {
        ProposalInit    init    = 1;
        ProposalContent content = 2;
        ProposalFin     fin     = 3;
    }
}

// A proposal is a stream:
// 1. The first message is `init`.
// 2. The next N messages are `content`.
// 3. The last message is `fin`.
message ProposalMessage {
    repeated ProposalPart parts = 1;
}

message CertificateInit {
    ProposalInit       init             = 1;
    Hash               block_hash       = 2;
    // Proposer's signature of (block_location, round, block_hash).
    ConsensusSignature block_signature  = 3;
    // Votes of 1 type which form a quorum in favor of the proposal.
    repeated Vote      votes            = 4;
}

// A proposal is a stream:
// 1. The first message is `init`.
// 2. The next N messages are `content`.
message Certificate {
    oneof messages {
        CertificateInit init    = 1;
        ProposalContent content = 2;
    }
}

message PeerState {
    BlockLocation      block_location = 1;
    uint32             round          = 2;
    Step               step           = 3;
    uint32             valid_round    = 4;
    Hash               valid_value    = 5;
    Address            sender         = 6;
    // Sender's signature on the above fields.
    ConsensusSignature signature      = 7;
}
