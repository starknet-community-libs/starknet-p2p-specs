syntax = "proto3";

import "common.proto";
import "google/protobuf/timestamp.proto";

package consensus;


// WIP - will change

message Transaction {
    bytes elements = 1;
}

message TransactionBatch {
    repeated Transaction transactions = 1;
}

message Proof {
    bytes elements = 1;
}

message BlockNumber {
    Hash   parent_hash = 1;
    uint64 height      = 2;
    uint64 fork_id     = 3;
}

enum Step {
    Propose = 0;
    Prevote = 1;
    Precommit = 2;
}

message Voter {
    Address address = 1;
    uint64  weight  = 2;
}

message Vote {
    enum  VoteType {
        Prevote   = 0;
        Precommit = 1;
    };

    // We use a type field to distinguish between prevotes and precommits instead of different
    // messages, to make sure the data, and therefore the signature, are unambiguous, since the
    // votes have the same fields.
    VoteType           vote_type    = 1;
    uint64             fork_id      = 2;
    BlockNumber        block_number = 3;
    uint32             round        = 4;
    // This is optional since a vote can be NIL.
    optional Hash      block_hash   = 5;
    // Identifies the voter.
    Address            voter        = 6;
    // Voter's signature of the above fields.
    ConsensusSignature signature    = 7;
}

message ProposalInit {
    BlockNumber               block_number   = 1;
    uint32                    proposal_round = 2;
    uint32                    valid_round    = 3;
    Address                   proposer       = 4;
    google.protobuf.Timestamp timestamp      = 5;
    // The validator set which can vote on this block.
    repeated Voter            validators     = 6;
}

// Any content in the block itself, which is opaque to the consensus module (e.g. transactions,
// proofs, gas price, etc.)
message ProposalContent {
    oneof content {
        TransactionBatch transactions = 1;
        Proof            proof        = 2;
    }
}

message ProposalFin {
    // Proposer's signature of `block_hash`.
    ConsensusSignature block_signature  = 1;
}

// A proposal is a stream:
// 1. The first message is `init`.
// 2. The next N messages are `content`.
// 3. The last message is `fin`.
message Proposal {
    oneof messages {
        ProposalInit    init    = 1;
        ProposalContent content = 2;
        ProposalFin     fin     = 3;
    }
}

message CertificateInit {
    ProposalInit       init             = 1;
    // Votes of 1 type which form a quorum in favor of the proposal.
    repeated Vote      votes            = 2;
    // Proposer's signature of `block_hash`.
    ConsensusSignature block_signature  = 3;
}

// A proposal is a stream:
// 1. The first message is `init`.
// 2. The next N messages are `content`.
message Certificate {
    oneof messages {
        CertificateInit init    = 1;
        ProposalContent content = 2;
    }
}

message PeerState {
    BlockNumber        block_number = 1;
    uint32             round        = 2;
    Step               step         = 3;
    uint32             valid_round  = 4;
    Hash               valid_value  = 5;
}
